#include <clustering/local_search.hpp>

using namespace clustering;

LocalSearch::LocalSearch(uint k, uint s) : numOfClusters(k), swapSize(s)
{
}

std::shared_ptr<ClusteringResult>
LocalSearch::run(const blaze::DynamicMatrix<double> &data)
{
    size_t n = data.rows();
    size_t k = this->numOfClusters;

    KMeans kMeansAlg(this->numOfClusters, true, 100U, 0.0001, 42);
    
    // Initialise centers using  k-Means++.
    auto centers = kMeansAlg.initCentroidsKMeansPlusPlus(data);

    // Assign points to clusters using initial centers generated by k-Means++ initialisation.
    ClusterAssignmentList clusterAssignments(n, this->numOfClusters);
    clusterAssignments.assignAll(data, centers);

    // Let the cost of the above clusterings be the best cost seen so far.
    double bestCost = clusterAssignments.calcCost();
    auto bestCenters = centers;
    auto swapClusterAssignments = clusterAssignments;
    auto bestClusterAssignments = swapClusterAssignments;

    printf("Cost before swaps %0.5f\n", bestCost);

    std::cout << "Best centers: \n" << bestCenters << "\n";

    for (size_t c = 0; c < k; c++)
    {
        for (size_t p = 0; p < n; p++)
        {
            // Swap one center (c) with a point (p)
            blaze::row(centers, c) = blaze::row(data, p);

            // Reassign points to potentially new centers after the swap.
            swapClusterAssignments.assignAll(data, centers);

            // The cost after the swap.
            double cost = swapClusterAssignments.calcCost();

            printf("Swaping cluster %3ld with point %3ld result in cost %0.5f\n", c, p, cost);

            if (cost < bestCost)
            {
                bestCost = cost;
                bestCenters = centers;
                bestClusterAssignments = swapClusterAssignments;
                std::cout << "Found new best centers: \n" << bestCenters << "\n";
            }
        }
    }
    
    return std::make_shared<ClusteringResult>(bestClusterAssignments, bestCenters);
}
